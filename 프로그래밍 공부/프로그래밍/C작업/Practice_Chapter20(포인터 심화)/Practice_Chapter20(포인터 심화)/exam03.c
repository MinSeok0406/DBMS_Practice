//포인터 심화 예제-3

//void형 포인터 : void형 포인터는 어떠한 데이터 타입이라도 상관없이 데이터 처리할 수 있는 그러한 포인터 형태이다.
//문자형 포인터, 정수형 포인터, 실수형 포인터를 void형 포인트 형태로 취급할 수가 있다. 하지만,
//명시적인 대상을 가리키는 포인터 타입으로 자료형을 캐스팅을 해주어야 하는 단점이 존재한다.
//void형 포인터는 void* vp = NULL; 선언 및 초기화를 하여 다른 데이터 타입을 얼마든지 저장할 수가 있는 것이다.
//메모리를 그나마 효율적으로 사용하고자 할 때 다양한 타입의 포인터를 선언하는 것보다는 메모리적인 측면에서
//장점을 보인다.

#include <stdio.h>

int main(void)
{
	int num = 123;
	float f_num = 58.77f;
	char ch = 'A';
	int arr[5] = { 1,2,3,4,5 };

	//void형 포인터를 선언 및 초기화
	void* vp = NULL;
	printf("void형 포인터의 바이트 크기 : %d\n", sizeof(vp));

	//void형 포인터를 NULL초기화를 했기에 주소는 0번지이다.
	printf("void형 포인터의 주소 : %p\n", vp);

	//아래 코드는 에러가 발생한다. 그 이유는 void* 타입이기에 현재 가리키고 있는 값이 존재하지 않기
	//때문이다.
	//printf("void형 포인터가 가지고 있는 값 : %d\n", *vp);

	printf("\n----------------------------------------------------\n");

	vp = &num;		//정수형 변수의 주소값을 void형 포인터에 대입
	printf("void형 포인터가 가지고 있는 값 : %d\n", *(int*)vp);
	printf("num의 주소 : %p\n", &num);
	printf("void형 포인터의 주소값 : %p\n", vp);

	printf("\n----------------------------------------------------\n");

	vp = &f_num;	//실수형 변수의 주소값을 void형 포인터에 대입
	printf("void형 포인터가 가지고 있는 값 : %f\n", *(float*)vp);
	printf("num의 주소 : %p\n", &f_num);
	printf("void형 포인터의 주소값 : %p\n", vp);

	printf("\n----------------------------------------------------\n");

	vp = &ch;		//문자형 변수의 주소값을 void형 포인터에 대입
	printf("void형 포인터가 가지고 있는 값 : %c\n", *(char*)vp);
	printf("num의 주소 : %p\n", &ch);
	printf("void형 포인터의 주소값 : %p\n", vp);

	printf("\n----------------------------------------------------\n");

	vp = arr;		//배열명(주소)를 void형 포인터 대입함
	for (int i = 0; i < 5; i++)
	{
		printf("void형 포인터 주소 : %p\n", vp);
		printf("arr[%d] = %d\n", i, *(int*)vp);
		//vp++;		//가리키고 있는 대상의 캐스팅 처리가 안되어서 크기를 알수가 없어 에러가 발생
		vp = (int*)vp + 1;
		//((int*)vp)++;		//사용가능
		//연산자의 우선순위 때문에 ++연산이 캐스팅보다 먼저 실행되기 때문에 에러가 발생
		//vp = (int*)vp++;
	}




	return 0;
}