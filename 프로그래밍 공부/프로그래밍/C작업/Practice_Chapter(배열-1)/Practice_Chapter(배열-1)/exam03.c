//배열에 대한 실습-3
//배열의 크기(길이, length)는 [ ]안에 0을 초과하는 정수값이 들어가야한다.몇 개의 배열방을 만들것인지
//지정을 해야한다. 지정을 해야하다 보니 인덱스가 초과가 되어버리면 저장할 방도 없는데 데이터를 저장을
//할 수 없는 문제가 발생되면, 반대로 저장할 데이터가 적게 들어오면 되려 메모리의 낭비를 가져오게 된다.
//이게 바로 배열의 정적인 문제였다. 배열을 선언할 때, [ ]에 변수 이름이나 음수, 실수값을 지정하면 바로 컴파일 에러가 발생한다.

//배열의 크기에 대한 예제-1
//#include <stdio.h>
//
//int main(void) {
//	int size = 5;
//	int weight[size];			//변수가 배열의 크기로 들어가니 에러 발생
//	int score[0];				//배열의 크기에는 0을 초과하는 정수형 상수값이 들어가지 않아 에러발생
//	int sum[-10];				//배열의 크기에는 음수의 정수값이 들어갈 수가 없기 때문에 에러발생
//	float point[8.77];			//배열의 크기에는 정수형 상수값이 들어가야 되는데 실수형 상수값이 들어왔기 때문에 에러가 발생
//	double real_num_double[10];	//배열의 크기로 정수형 상수값이 들어갔기 때문에 에러 미발생
//
//
//	return 0;
//}

//배열의 크기에 대한 예제-2
//배열은 메모리의 공간을 연속된 영역을 지정하면서 할당이 된다.배열의 크기는 0을 초과한 정수형 상수값을 허용하는 것을 보았다.
//그러나 현업에서는 #define 매크로 상수 값을 이용하여 배열의 크기를 정하는 경우 대다수이다.
//그 이유는 배열의 크기의 변동이 온다면 매크로 상수의 값만 변경시켜주면 프로그램 유지, 보수가 쉬워진다.

//#include <stdio.h>
//#define LENGTH 10		//매크로 상수 선언 및 초기화
//
//int main(void) {
//
//	int score[LENGTH] = {0};	//매크로 상수를 배열의 크기로 지정하니 에러가 발생하지 않음.
//	int i = 0;
//	for (i = 0; i < LENGTH; i++)
//	{
//		printf("score[%d] : %d\n", i, score[i]);
//	}
//
//	return 0;
//}

//배열의 크기에 대한 예제-3
//#include <stdio.h>
//#define LENGTH 5		//매크로 상수 선언 및 초기화
//
//int main(void) {
//	//아래와 같이 배열의 크기를 주지 아니하면 배열의 크기를 컴파일러가 모르기 때문에 에러가 발생
//	//int jumsu[];
//
//	int score[LENGTH] = { 88,77,100,26,77 };	//배열의 크기는 5가 된다.
//	//아래와 같이 배열의 크기를 주지 아니했으나 초기화를 했기에 컴파일러는 초기화 된 값을 가지고 배열의 크기를 잡아준다.
//	int jumsu[] = {7,10,15,43,45,88,100};	
//
//	for (int i = 0; i < sizeof(jumsu) / sizeof(int); i++)
//	{
//		printf("jumsu[%d] : %d\n", i, jumsu[i]);
//	}
//
//	//결론은 배열의 크기를 잡을 때, 웬만하면 유지, 보수 측면이나 프로그래머가 편하기 위해서는
//	//매크로 상수를 이용하는 것이 가장 바람직하다.
//
//	return 0;
//}

//배열의 크기에 대한 예제-4
//#include <stdio.h>
//#define LENGTH 3
//int main(void) {
//
//	int score[LENGTH] = { 10,20,30 };
//	//아래 코드는 배열의 크기가 3인데 인덱스 3인 방은 존재하지 않는데 40을 대입시키므로
//	//런타임 에러(indexOutOfBounds Error)가 발생한 것이다.
//	//int score_over[LENGTH] = { 10,20,30,40 };
//	int score_min[LENGTH];
//
//	//특정 인덱스만 초기화를 하게 되면, 나머지 방의 값들은 역시 쓰레기 값으로 채워진 것을 알수 가 있다.
//	score_min[2] = 66;
//	printf("score_min[0] : %d\n", score_min[0]);
//	printf("score_min[1] : %d\n", score_min[1]);
//	printf("score_min[2] : %d\n", score_min[2]);
//	
//	// 배열을 사용할 때 주의사항
//	//1. 배열의 인덱스(첨자) 항상 0부터 시작
//	//2. 배열명은 곧 주소다.(배열[0]의 주소와 동일)
//	//3. 배열의 선언과 함께 초기화 할 경우 배열의 크기는 생략이 가능하다.(권고사항은 아님)
//	//4. 배열의 크기보다 큰 인덱스에 값을 저장 및 출력을 하면 에러발생(방이 없다)
//	//5. 배열의 크기보다 특정 인덱스만 값을 초기화하면 나머지 방의 값은 쓰레기 값으로 채워진다.
//	//   메모리적인 측면에서 낭비가 된다.
//
//
//	return 0;
//}