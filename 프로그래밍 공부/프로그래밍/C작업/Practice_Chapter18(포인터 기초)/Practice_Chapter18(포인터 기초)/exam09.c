//포인터 실습 - 9
//포인터와 배열의 관계
//포인터와 배열을 사용하여 배열 요소 출력

//#include <stdio.h>
//#define LENGTH 5
//
//int main(void)
//{
//	int arr[LENGTH] = { 100,200,300,400,500 };
//	int i = 0;
//
//	printf("int arr[LENGTH] = { 100,200,300,400,500 }; 일 떄\n");
//
//	printf("\n1. 배열 요소의 주소값 출력 \n");
//	for (i = 0; i < LENGTH; i++)
//	{
//		printf("%d번째 배열 요소 arr[%d] = &arr[%p]\n", i, i, &arr[i]);
//	}
//
//	printf("\n2. 주소값과 배열 요소의 값 출력\n");
//	//배열명을 가지고 주소도 출력하고 값도 출력하고 있다. 왜? 배열명은 곧 포인터니깐...
//	printf("배열의 현재 주소값 : arr은 %p\n", arr);
//	printf("첫 번째 배열 요소의 값 : %d \n", *arr);
//
//	//배열의 주소값을 배열명으로 이동 후 주소값 출력
//	//배열명(포인터 상수)으로 ++, -- 연산은 불가능
//	printf("\n증감 연산 후 주소값 : arr + 1은 %p\n", arr + 1);
//	//주소를 이동함과 동시에 해당 주소값의 실제값을 출력
//	printf("증감 연산 후 배열 요소의 값 : *(arr + 1)은 %d\n", *(arr + 1));
//	printf("\n배열의 현재 주소값 : arr은 %p\n", arr);
//	//배열 주소값 이동 후 주소값 출력 : 배열명으로 주소값을 이동한다라는 개념이 아니고
//	//잠깐 인덱스의 값을 받아서 주소를 출력하는 그런 개념
//	printf("\n배열의 현재 주소값 : arr은 %p\n", arr);
//	printf("증감 연산 후 주소값 : arr + 2은 %p\n", arr + 2);
//	printf("증감 연산 후 배열 요소의 값 : *(arr + 2)는 %d\n", *(arr + 2));
//
//	printf("\n-------------------------------------------------------------------------\n");
//	printf("증감 연산 후 배열 요소의 값 : *(arr + 2)는 %d\n", *(arr + 2));
//	int dif = *(arr + 2) - 10;
//	printf("증감 연산 후 배열 요소의 값 : *(arr + 2) - 10는 %d\n", dif);
//
//	return 0;
//
//	//결론 : 포인터 연산관 배열명으로써의 연산은 아주 다른 맥락에서 접근을 해야한다.
//	//포인터를 통한 연산은 실질적으로 배열주소나 배열 요소에서 간접참조를 통해서 실제값을
//	//변경을 시키거나 주소값을 이동시킬 수 있지만, 배열명으로 값을 변경을 한다거나 주소값을
//	//이동하는 것은 잠시잠깐 참조를 통하여 출력은 할 수 있으나 원래값은 변경되지 아니한다.
//	//포인터 변수로 조작하는 것이 배열명으로 조작하는 것보다 훨씬 유연성이 뛰어나다
//	//중요한 내용
//	//배열도 포인터로 취급되지만 배열명에 다른 배열명이나 변수의 주소를 저장할 수 없다.
//	//그 이유는 C언어에서는 배열명은 곧 포인터 상수(변하지 않는 주소값)로 취급되기 때문이다.
//}