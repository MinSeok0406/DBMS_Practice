//포인터 활용에 대한 실습-2
//포인터 배열 : 포인터(주소값)를 배열의 요소로 사용하겠다라는 배열을 의미한다.
//일반 문자열 배열은 2차원 배열로 설정을 하여 여러 개의 문자열을 다룰 수가 있는데 중요한 건
//배열요소 중에서 가장 긴 문자열을 기준으로 하여 배열요소의 방을 생성을 할 수 밖에 없다. 왜?
//배열은 정적이기 때문이다. 짧은 문자열의 경우는 메모리의 낭비를 초래하게 되는 결과를 준다.
//포인터 배열을 사용하면 일반 문자형 배열에 비해 문자열 상수의 시작 주소만 저장하기 위한 별도의 포인터 배열의 공간만
//확보하면 되고 문자열 상수의 값들은 컴파일러가 알아서 메모리 낭비 없이 할당을 해주니 일반 문자형 배열 보다 훨씬
//메모리적인 측면이 효율적이다.
//포인터 배열은 메모리 공간을 문자열 상수의 길이에 따라 가변적으로 확보해 주는 레그드(regged array)배열이라고도 한다.

//#include <stdio.h>
//
//int main(void)
//{
//	int i = 0, length = 0, choice = 0;
//	//포인터 배열을 선언과 동시에 초기화
//	char* task[] = {
//						"한국",
//						"USA",
//						"우즈베키스탄",
//						"나이지리아",
//						"도미니카공화국"
//					};
//
//	//포인터 배열의 각각의 바이트 수를 출력
//	//배열 요소 즉 포인터 모두 8바이트 이므로 8 * 5 = 40바이트가 할당된다.
//	printf("task의 바이트 수 : %d\n", sizeof(task));
//	printf("task[3]의 바이트 수 : %d\n", sizeof(task[3]));
//
//	//포인터 배열의 길이를 구하는 코드
//	length = sizeof(task) / sizeof(task[0]);	// 40 / 8 = 5
//
//	//문자열 상수들의 값들을 출력
//	for (i = 0; i < length; i++)
//	{
//		printf("%2d. %s\n", i + 1, task[i]);
//	}
//	printf("\n-------------------------------------------\n");
//	//포인터 배열의 주소값들을 출력
//	/*for (i = 0; i < length; i++)
//	{
//		printf("task[%d]의 주소 : %p\n", i, &task[i]);
//	}*/
//	
//	printf("포인터 배열 요소 선택(종료 : 6)\n");
//	//무한루프
//	while (1)
//	{
//		printf("\n숫자 입력(1 ~ 6) : ");
//		scanf_s("%d", &choice);
//		//에러 처리
//		if (choice < 1 || choice > 6)
//		{
//			printf("입력 숫자 오류!\n");
//			continue;
//		}
//		else if (choice == 6)
//		{
//			printf("프로그램을 종료합니다.!\n");
//			break;
//		}
//		else
//		{
//			printf("선택한 단어는 \"%s\" 입니다.\n\n", task[choice - 1]);
//		}
//	}
//
//	return 0;
//}