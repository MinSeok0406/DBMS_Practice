//포인터 활용에 대한 실습-1

//C언어에서는 문자열을 위한 자료형(데이터 타입)이 존재하지가 않는다. 문자열을 처리하기 위해서는
//지금까지는 문자형 배열을 활용하여 문자열을 사용했다. 포인터도 역시 문자열을 처리를 할 수 있기
//때문에 그 부분을 배열과 포인터의 문자열 처리 부분을 같이 비교를 해보도록 하자.

//#include <stdio.h>
//
//int main(void)
//{
//	char ch_Arr[] = "C_Program";		//사이즈가 10바이트
//	char* pch = "C_Program";			//사이즈가 8바이트(주소만 가지고 있기 때문이다)
//	int i = 0;
//
//	printf("ch_Arr[]배열의 바이트 크기 : %d\n", sizeof(ch_Arr));
//	printf("pch가 가리키는 문자열 바이트 크기 : %d\n", sizeof(pch));
//	printf("\n-----------------------------------------------------\n");
//
//	//서로의 주소값이 틀리다라는 것은 당연한 것이다.
//	printf("ch_Arr의 주소 : %p \n", ch_Arr);
//	printf("pch의 주소 : %p \n", pch);
//
//	printf("\n-----------------------------------------------------\n");
//
//	//배열명의 인덱스를 통해서 배열은 언제든지 배열 요소가 변경 가능하다.
//	ch_Arr[0] = 'S';
//	//포인터가 가리키고 있는 문자열의 문자는 변경이 안된다.(중요)
//	//*(pch + 0) = 'S';		이 코드는 허용이 안된다.
//	//왜? 포인터는 가리키는 주소만 가지고 있고 그 주소에 있는 값은 문자열 상수이기 때문이다.
//
//	printf("포인터 pch가 가리키고 있는 문자열 : %s\n", pch);
//
//	printf("[배열 사용] \t [포인터 사용] \n");
//	for (i = 0; i < 9; i++)
//	{
//		printf("ch_Arr[%d] : %c\t ", i, ch_Arr[i]);
//		//문자값을 읽는 것이다. 하지만 주소는 이동이 일어나는 것이 아니다.
//		printf("*(pch + %d) : %c\n", i, *(pch + i));
//		//포인터로 가리키고 있는 문자열 상수도 인덱스를 이용하여 문자를 출력할 수가 있다.
//		//printf("pch[%d] : %c\t ", i, pch[i]);
//		//포인터로 ++연산을 통하여 문자값을 출력할 순 있지만 1바이트씩 주소이동이 일어나서 혼란스럽다.
//		//printf("*(pch++) : %c\t " , *(pch++));
//	}
//	//NULL포함되어 있는지 여부를 확인하는 코드
//	printf("ch_Arr[9] : %d\t ", ch_Arr[9]);
//	printf("*(pch + 9) : %d\n", *(pch + 9));
//
//	return 0;
//}